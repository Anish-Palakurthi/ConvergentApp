{"ast":null,"code":"\n\n'use strict';\n\nvar _global$HermesInterna, _global$HermesInterna2;\nvar _require = require(\"../Utilities/PolyfillFunctions\"),\n  polyfillGlobal = _require.polyfillGlobal;\nvar _require2 = require(\"../Utilities/FeatureDetection\"),\n  isNativeFunction = _require2.isNativeFunction;\nif (__DEV__) {\n  if (typeof global.Promise !== 'function') {\n    console.error('Promise should exist before setting up timers.');\n  }\n}\n\nvar hasHermesPromiseQueuedToJSVM = ((_global$HermesInterna = global.HermesInternal) == null ? void 0 : _global$HermesInterna.hasPromise == null ? void 0 : _global$HermesInterna.hasPromise()) === true && ((_global$HermesInterna2 = global.HermesInternal) == null ? void 0 : _global$HermesInterna2.useEngineQueue == null ? void 0 : _global$HermesInterna2.useEngineQueue()) === true;\nvar hasNativePromise = isNativeFunction(Promise);\nvar hasPromiseQueuedToJSVM = hasNativePromise || hasHermesPromiseQueuedToJSVM;\n\nif (global.RN$Bridgeless !== true) {\n  var defineLazyTimer = function defineLazyTimer(name) {\n    polyfillGlobal(name, function () {\n      return require(\"./Timers/JSTimers\")[name];\n    });\n  };\n  defineLazyTimer('setTimeout');\n  defineLazyTimer('clearTimeout');\n  defineLazyTimer('setInterval');\n  defineLazyTimer('clearInterval');\n  defineLazyTimer('requestAnimationFrame');\n  defineLazyTimer('cancelAnimationFrame');\n  defineLazyTimer('requestIdleCallback');\n  defineLazyTimer('cancelIdleCallback');\n}\n\nif (hasPromiseQueuedToJSVM) {\n  polyfillGlobal('setImmediate', function () {\n    return require(\"./Timers/immediateShim\").setImmediate;\n  });\n  polyfillGlobal('clearImmediate', function () {\n    return require(\"./Timers/immediateShim\").clearImmediate;\n  });\n} else {\n  if (global.RN$Bridgeless !== true) {\n    polyfillGlobal('setImmediate', function () {\n      return require(\"./Timers/JSTimers\").queueReactNativeMicrotask;\n    });\n    polyfillGlobal('clearImmediate', function () {\n      return require(\"./Timers/JSTimers\").clearReactNativeMicrotask;\n    });\n  }\n}\n\nif (hasHermesPromiseQueuedToJSVM) {\n  polyfillGlobal('queueMicrotask', function () {\n    var _global$HermesInterna3;\n    return (_global$HermesInterna3 = global.HermesInternal) == null ? void 0 : _global$HermesInterna3.enqueueJob;\n  });\n} else {\n  polyfillGlobal('queueMicrotask', function () {\n    return require(\"./Timers/queueMicrotask.js\").default;\n  });\n}","map":{"version":3,"names":["require","polyfillGlobal","isNativeFunction","__DEV__","global","Promise","console","error","hasHermesPromiseQueuedToJSVM","HermesInternal","hasPromise","useEngineQueue","hasNativePromise","hasPromiseQueuedToJSVM","RN$Bridgeless","defineLazyTimer","name","setImmediate","clearImmediate","queueReactNativeMicrotask","clearReactNativeMicrotask","enqueueJob","default"],"sources":["C:/Users/kvnem/ConvergentApp/node_modules/react-native/Libraries/Core/setUpTimers.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\n'use strict';\r\n\r\nconst {polyfillGlobal} = require('../Utilities/PolyfillFunctions');\r\nconst {isNativeFunction} = require('../Utilities/FeatureDetection');\r\n\r\nif (__DEV__) {\r\n  if (typeof global.Promise !== 'function') {\r\n    console.error('Promise should exist before setting up timers.');\r\n  }\r\n}\r\n\r\n// Currently, Hermes `Promise` is implemented via Internal Bytecode.\r\nconst hasHermesPromiseQueuedToJSVM =\r\n  global.HermesInternal?.hasPromise?.() === true &&\r\n  global.HermesInternal?.useEngineQueue?.() === true;\r\n\r\nconst hasNativePromise = isNativeFunction(Promise);\r\nconst hasPromiseQueuedToJSVM = hasNativePromise || hasHermesPromiseQueuedToJSVM;\r\n\r\n// In bridgeless mode, timers are host functions installed from cpp.\r\nif (global.RN$Bridgeless !== true) {\r\n  /**\r\n   * Set up timers.\r\n   * You can use this module directly, or just require InitializeCore.\r\n   */\r\n  const defineLazyTimer = (\r\n    name:\r\n      | $TEMPORARY$string<'cancelAnimationFrame'>\r\n      | $TEMPORARY$string<'cancelIdleCallback'>\r\n      | $TEMPORARY$string<'clearInterval'>\r\n      | $TEMPORARY$string<'clearTimeout'>\r\n      | $TEMPORARY$string<'requestAnimationFrame'>\r\n      | $TEMPORARY$string<'requestIdleCallback'>\r\n      | $TEMPORARY$string<'setInterval'>\r\n      | $TEMPORARY$string<'setTimeout'>,\r\n  ) => {\r\n    polyfillGlobal(name, () => require('./Timers/JSTimers')[name]);\r\n  };\r\n  defineLazyTimer('setTimeout');\r\n  defineLazyTimer('clearTimeout');\r\n  defineLazyTimer('setInterval');\r\n  defineLazyTimer('clearInterval');\r\n  defineLazyTimer('requestAnimationFrame');\r\n  defineLazyTimer('cancelAnimationFrame');\r\n  defineLazyTimer('requestIdleCallback');\r\n  defineLazyTimer('cancelIdleCallback');\r\n}\r\n\r\n/**\r\n * Set up immediate APIs, which is required to use the same microtask queue\r\n * as the Promise.\r\n */\r\nif (hasPromiseQueuedToJSVM) {\r\n  // When promise queues to the JSVM microtasks queue, we shim the immedaite\r\n  // APIs via `queueMicrotask` to maintain the backward compatibility.\r\n  polyfillGlobal(\r\n    'setImmediate',\r\n    () => require('./Timers/immediateShim').setImmediate,\r\n  );\r\n  polyfillGlobal(\r\n    'clearImmediate',\r\n    () => require('./Timers/immediateShim').clearImmediate,\r\n  );\r\n} else {\r\n  // When promise was polyfilled hence is queued to the RN microtask queue,\r\n  // we polyfill the immediate APIs as aliases to the ReactNativeMicrotask APIs.\r\n  // Note that in bridgeless mode, immediate APIs are installed from cpp.\r\n  if (global.RN$Bridgeless !== true) {\r\n    polyfillGlobal(\r\n      'setImmediate',\r\n      () => require('./Timers/JSTimers').queueReactNativeMicrotask,\r\n    );\r\n    polyfillGlobal(\r\n      'clearImmediate',\r\n      () => require('./Timers/JSTimers').clearReactNativeMicrotask,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Set up the microtask queueing API, which is required to use the same\r\n * microtask queue as the Promise.\r\n */\r\nif (hasHermesPromiseQueuedToJSVM) {\r\n  // Fast path for Hermes.\r\n  polyfillGlobal('queueMicrotask', () => global.HermesInternal?.enqueueJob);\r\n} else {\r\n  // Polyfill it with promise (regardless it's polyfiled or native) otherwise.\r\n  polyfillGlobal(\r\n    'queueMicrotask',\r\n    () => require('./Timers/queueMicrotask.js').default,\r\n  );\r\n}\r\n"],"mappings":";;AAUA,YAAY;;AAAC;AAEb,eAAyBA,OAAO,kCAAkC;EAA3DC,cAAc,YAAdA,cAAc;AACrB,gBAA2BD,OAAO,iCAAiC;EAA5DE,gBAAgB,aAAhBA,gBAAgB;AAEvB,IAAIC,OAAO,EAAE;EACX,IAAI,OAAOC,MAAM,CAACC,OAAO,KAAK,UAAU,EAAE;IACxCC,OAAO,CAACC,KAAK,CAAC,gDAAgD,CAAC;EACjE;AACF;;AAGA,IAAMC,4BAA4B,GAChC,0BAAAJ,MAAM,CAACK,cAAc,qBAArB,sBAAuBC,UAAU,oBAAjC,sBAAuBA,UAAU,EAAI,MAAK,IAAI,IAC9C,2BAAAN,MAAM,CAACK,cAAc,qBAArB,uBAAuBE,cAAc,oBAArC,uBAAuBA,cAAc,EAAI,MAAK,IAAI;AAEpD,IAAMC,gBAAgB,GAAGV,gBAAgB,CAACG,OAAO,CAAC;AAClD,IAAMQ,sBAAsB,GAAGD,gBAAgB,IAAIJ,4BAA4B;;AAG/E,IAAIJ,MAAM,CAACU,aAAa,KAAK,IAAI,EAAE;EAKjC,IAAMC,eAAe,GAAG,SAAlBA,eAAe,CACnBC,IAQmC,EAChC;IACHf,cAAc,CAACe,IAAI,EAAE;MAAA,OAAMhB,OAAO,qBAAqB,CAACgB,IAAI,CAAC;IAAA,EAAC;EAChE,CAAC;EACDD,eAAe,CAAC,YAAY,CAAC;EAC7BA,eAAe,CAAC,cAAc,CAAC;EAC/BA,eAAe,CAAC,aAAa,CAAC;EAC9BA,eAAe,CAAC,eAAe,CAAC;EAChCA,eAAe,CAAC,uBAAuB,CAAC;EACxCA,eAAe,CAAC,sBAAsB,CAAC;EACvCA,eAAe,CAAC,qBAAqB,CAAC;EACtCA,eAAe,CAAC,oBAAoB,CAAC;AACvC;;AAMA,IAAIF,sBAAsB,EAAE;EAG1BZ,cAAc,CACZ,cAAc,EACd;IAAA,OAAMD,OAAO,0BAA0B,CAACiB,YAAY;EAAA,EACrD;EACDhB,cAAc,CACZ,gBAAgB,EAChB;IAAA,OAAMD,OAAO,0BAA0B,CAACkB,cAAc;EAAA,EACvD;AACH,CAAC,MAAM;EAIL,IAAId,MAAM,CAACU,aAAa,KAAK,IAAI,EAAE;IACjCb,cAAc,CACZ,cAAc,EACd;MAAA,OAAMD,OAAO,qBAAqB,CAACmB,yBAAyB;IAAA,EAC7D;IACDlB,cAAc,CACZ,gBAAgB,EAChB;MAAA,OAAMD,OAAO,qBAAqB,CAACoB,yBAAyB;IAAA,EAC7D;EACH;AACF;;AAMA,IAAIZ,4BAA4B,EAAE;EAEhCP,cAAc,CAAC,gBAAgB,EAAE;IAAA;IAAA,iCAAMG,MAAM,CAACK,cAAc,qBAArB,uBAAuBY,UAAU;EAAA,EAAC;AAC3E,CAAC,MAAM;EAELpB,cAAc,CACZ,gBAAgB,EAChB;IAAA,OAAMD,OAAO,8BAA8B,CAACsB,OAAO;EAAA,EACpD;AACH"},"metadata":{},"sourceType":"script"}