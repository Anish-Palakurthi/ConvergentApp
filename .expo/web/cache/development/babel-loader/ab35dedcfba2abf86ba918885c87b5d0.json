{"ast":null,"code":"\n\nvar BatchedBridge = require(\"../../BatchedBridge/BatchedBridge\");\nvar Systrace = require(\"../../Performance/Systrace\");\nvar invariant = require('invariant');\nimport NativeTiming from \"./NativeTiming\";\n\nvar FRAME_DURATION = 1000 / 60;\nvar IDLE_CALLBACK_FRAME_DEADLINE = 1;\n\nvar callbacks = [];\nvar types = [];\nvar timerIDs = [];\nvar reactNativeMicrotasks = [];\nvar requestIdleCallbacks = [];\nvar requestIdleCallbackTimeouts = {};\nvar GUID = 1;\nvar errors = [];\nvar hasEmittedTimeDriftWarning = false;\n\nfunction _getFreeIndex() {\n  var freeIndex = timerIDs.indexOf(null);\n  if (freeIndex === -1) {\n    freeIndex = timerIDs.length;\n  }\n  return freeIndex;\n}\nfunction _allocateCallback(func, type) {\n  var id = GUID++;\n  var freeIndex = _getFreeIndex();\n  timerIDs[freeIndex] = id;\n  callbacks[freeIndex] = func;\n  types[freeIndex] = type;\n  return id;\n}\n\nfunction _callTimer(timerID, frameTime, didTimeout) {\n  if (timerID > GUID) {\n    console.warn('Tried to call timer with ID %s but no such timer exists.', timerID);\n  }\n\n  var timerIndex = timerIDs.indexOf(timerID);\n  if (timerIndex === -1) {\n    return;\n  }\n  var type = types[timerIndex];\n  var callback = callbacks[timerIndex];\n  if (!callback || !type) {\n    console.error('No callback found for timerID ' + timerID);\n    return;\n  }\n  if (__DEV__) {\n    Systrace.beginEvent(type + ' [invoke]');\n  }\n\n  if (type !== 'setInterval') {\n    _clearIndex(timerIndex);\n  }\n  try {\n    if (type === 'setTimeout' || type === 'setInterval' || type === 'queueReactNativeMicrotask') {\n      callback();\n    } else if (type === 'requestAnimationFrame') {\n      callback(global.performance.now());\n    } else if (type === 'requestIdleCallback') {\n      callback({\n        timeRemaining: function timeRemaining() {\n          return Math.max(0, FRAME_DURATION - (global.performance.now() - frameTime));\n        },\n        didTimeout: !!didTimeout\n      });\n    } else {\n      console.error('Tried to call a callback with invalid type: ' + type);\n    }\n  } catch (e) {\n    errors.push(e);\n  }\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n}\n\nfunction _callReactNativeMicrotasksPass() {\n  if (reactNativeMicrotasks.length === 0) {\n    return false;\n  }\n  if (__DEV__) {\n    Systrace.beginEvent('callReactNativeMicrotasksPass()');\n  }\n\n  var passReactNativeMicrotasks = reactNativeMicrotasks;\n  reactNativeMicrotasks = [];\n\n  for (var i = 0; i < passReactNativeMicrotasks.length; ++i) {\n    _callTimer(passReactNativeMicrotasks[i], 0);\n  }\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n  return reactNativeMicrotasks.length > 0;\n}\nfunction _clearIndex(i) {\n  timerIDs[i] = null;\n  callbacks[i] = null;\n  types[i] = null;\n}\nfunction _freeCallback(timerID) {\n  if (timerID == null) {\n    return;\n  }\n  var index = timerIDs.indexOf(timerID);\n  if (index !== -1) {\n    var type = types[index];\n    _clearIndex(index);\n    if (type !== 'queueReactNativeMicrotask' && type !== 'requestIdleCallback') {\n      deleteTimer(timerID);\n    }\n  }\n}\n\nvar JSTimers = {\n  setTimeout: function setTimeout(func, duration) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'setTimeout');\n    createTimer(id, duration || 0, Date.now(), false);\n    return id;\n  },\n  setInterval: function setInterval(func, duration) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'setInterval');\n    createTimer(id, duration || 0, Date.now(), true);\n    return id;\n  },\n  queueReactNativeMicrotask: function queueReactNativeMicrotask(func) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'queueReactNativeMicrotask');\n    reactNativeMicrotasks.push(id);\n    return id;\n  },\n  requestAnimationFrame: function requestAnimationFrame(func) {\n    var id = _allocateCallback(func, 'requestAnimationFrame');\n    createTimer(id, 1, Date.now(), false);\n    return id;\n  },\n  requestIdleCallback: function requestIdleCallback(func, options) {\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(true);\n    }\n    var timeout = options && options.timeout;\n    var id = _allocateCallback(timeout != null ? function (deadline) {\n      var timeoutId = requestIdleCallbackTimeouts[id];\n      if (timeoutId) {\n        JSTimers.clearTimeout(timeoutId);\n        delete requestIdleCallbackTimeouts[id];\n      }\n      return func(deadline);\n    } : func, 'requestIdleCallback');\n    requestIdleCallbacks.push(id);\n    if (timeout != null) {\n      var timeoutId = JSTimers.setTimeout(function () {\n        var index = requestIdleCallbacks.indexOf(id);\n        if (index > -1) {\n          requestIdleCallbacks.splice(index, 1);\n          _callTimer(id, global.performance.now(), true);\n        }\n        delete requestIdleCallbackTimeouts[id];\n        if (requestIdleCallbacks.length === 0) {\n          setSendIdleEvents(false);\n        }\n      }, timeout);\n      requestIdleCallbackTimeouts[id] = timeoutId;\n    }\n    return id;\n  },\n  cancelIdleCallback: function cancelIdleCallback(timerID) {\n    _freeCallback(timerID);\n    var index = requestIdleCallbacks.indexOf(timerID);\n    if (index !== -1) {\n      requestIdleCallbacks.splice(index, 1);\n    }\n    var timeoutId = requestIdleCallbackTimeouts[timerID];\n    if (timeoutId) {\n      JSTimers.clearTimeout(timeoutId);\n      delete requestIdleCallbackTimeouts[timerID];\n    }\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(false);\n    }\n  },\n  clearTimeout: function clearTimeout(timerID) {\n    _freeCallback(timerID);\n  },\n  clearInterval: function clearInterval(timerID) {\n    _freeCallback(timerID);\n  },\n  clearReactNativeMicrotask: function clearReactNativeMicrotask(timerID) {\n    _freeCallback(timerID);\n    var index = reactNativeMicrotasks.indexOf(timerID);\n    if (index !== -1) {\n      reactNativeMicrotasks.splice(index, 1);\n    }\n  },\n  cancelAnimationFrame: function cancelAnimationFrame(timerID) {\n    _freeCallback(timerID);\n  },\n  callTimers: function callTimers(timersToCall) {\n    invariant(timersToCall.length !== 0, 'Cannot call `callTimers` with an empty list of IDs.');\n    errors.length = 0;\n    for (var i = 0; i < timersToCall.length; i++) {\n      _callTimer(timersToCall[i], 0);\n    }\n    var errorCount = errors.length;\n    if (errorCount > 0) {\n      if (errorCount > 1) {\n        for (var ii = 1; ii < errorCount; ii++) {\n          JSTimers.setTimeout(function (error) {\n            throw error;\n          }.bind(null, errors[ii]), 0);\n        }\n      }\n      throw errors[0];\n    }\n  },\n  callIdleCallbacks: function callIdleCallbacks(frameTime) {\n    if (FRAME_DURATION - (global.performance.now() - frameTime) < IDLE_CALLBACK_FRAME_DEADLINE) {\n      return;\n    }\n    errors.length = 0;\n    if (requestIdleCallbacks.length > 0) {\n      var passIdleCallbacks = requestIdleCallbacks;\n      requestIdleCallbacks = [];\n      for (var i = 0; i < passIdleCallbacks.length; ++i) {\n        _callTimer(passIdleCallbacks[i], frameTime);\n      }\n    }\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(false);\n    }\n    errors.forEach(function (error) {\n      return JSTimers.setTimeout(function () {\n        throw error;\n      }, 0);\n    });\n  },\n  callReactNativeMicrotasks: function callReactNativeMicrotasks() {\n    errors.length = 0;\n    while (_callReactNativeMicrotasksPass()) {}\n    errors.forEach(function (error) {\n      return JSTimers.setTimeout(function () {\n        throw error;\n      }, 0);\n    });\n  },\n  emitTimeDriftWarning: function emitTimeDriftWarning(warningMessage) {\n    if (hasEmittedTimeDriftWarning) {\n      return;\n    }\n    hasEmittedTimeDriftWarning = true;\n    console.warn(warningMessage);\n  }\n};\nfunction createTimer(callbackID, duration, jsSchedulingTime, repeats) {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.createTimer(callbackID, duration, jsSchedulingTime, repeats);\n}\nfunction deleteTimer(timerID) {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.deleteTimer(timerID);\n}\nfunction setSendIdleEvents(sendIdleEvents) {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.setSendIdleEvents(sendIdleEvents);\n}\nvar ExportedJSTimers;\nif (!NativeTiming) {\n  console.warn(\"Timing native module is not available, can't set timers.\");\n  ExportedJSTimers = {\n    callReactNativeMicrotasks: JSTimers.callReactNativeMicrotasks,\n    queueReactNativeMicrotask: JSTimers.queueReactNativeMicrotask\n  };\n} else {\n  ExportedJSTimers = JSTimers;\n}\nBatchedBridge.setReactNativeMicrotasksCallback(JSTimers.callReactNativeMicrotasks);\nmodule.exports = ExportedJSTimers;","map":{"version":3,"names":["BatchedBridge","require","Systrace","invariant","NativeTiming","FRAME_DURATION","IDLE_CALLBACK_FRAME_DEADLINE","callbacks","types","timerIDs","reactNativeMicrotasks","requestIdleCallbacks","requestIdleCallbackTimeouts","GUID","errors","hasEmittedTimeDriftWarning","_getFreeIndex","freeIndex","indexOf","length","_allocateCallback","func","type","id","_callTimer","timerID","frameTime","didTimeout","console","warn","timerIndex","callback","error","__DEV__","beginEvent","_clearIndex","global","performance","now","timeRemaining","Math","max","e","push","endEvent","_callReactNativeMicrotasksPass","passReactNativeMicrotasks","i","_freeCallback","index","deleteTimer","JSTimers","setTimeout","duration","args","apply","undefined","createTimer","Date","setInterval","queueReactNativeMicrotask","requestAnimationFrame","requestIdleCallback","options","setSendIdleEvents","timeout","deadline","timeoutId","clearTimeout","splice","cancelIdleCallback","clearInterval","clearReactNativeMicrotask","cancelAnimationFrame","callTimers","timersToCall","errorCount","ii","bind","callIdleCallbacks","passIdleCallbacks","forEach","callReactNativeMicrotasks","emitTimeDriftWarning","warningMessage","callbackID","jsSchedulingTime","repeats","sendIdleEvents","ExportedJSTimers","setReactNativeMicrotasksCallback","module","exports"],"sources":["C:/Users/kvnem/ConvergentApp/node_modules/react-native/Libraries/Core/Timers/JSTimers.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * @flow\r\n */\r\n\r\nconst BatchedBridge = require('../../BatchedBridge/BatchedBridge');\r\nconst Systrace = require('../../Performance/Systrace');\r\n\r\nconst invariant = require('invariant');\r\n\r\nimport NativeTiming from './NativeTiming';\r\n\r\n/**\r\n * JS implementation of timer functions. Must be completely driven by an\r\n * external clock signal, all that's stored here is timerID, timer type, and\r\n * callback.\r\n */\r\n\r\nexport type JSTimerType =\r\n  | 'setTimeout'\r\n  | 'setInterval'\r\n  | 'requestAnimationFrame'\r\n  | 'queueReactNativeMicrotask'\r\n  | 'requestIdleCallback';\r\n\r\n// These timing constants should be kept in sync with the ones in native ios and\r\n// android `RCTTiming` module.\r\nconst FRAME_DURATION = 1000 / 60;\r\nconst IDLE_CALLBACK_FRAME_DEADLINE = 1;\r\n\r\n// Parallel arrays\r\nconst callbacks: Array<?Function> = [];\r\nconst types: Array<?JSTimerType> = [];\r\nconst timerIDs: Array<?number> = [];\r\nlet reactNativeMicrotasks: Array<number> = [];\r\nlet requestIdleCallbacks: Array<number> = [];\r\nconst requestIdleCallbackTimeouts: {[number]: number, ...} = {};\r\n\r\nlet GUID = 1;\r\nconst errors: Array<Error> = [];\r\n\r\nlet hasEmittedTimeDriftWarning = false;\r\n\r\n// Returns a free index if one is available, and the next consecutive index otherwise.\r\nfunction _getFreeIndex(): number {\r\n  let freeIndex = timerIDs.indexOf(null);\r\n  if (freeIndex === -1) {\r\n    freeIndex = timerIDs.length;\r\n  }\r\n  return freeIndex;\r\n}\r\n\r\nfunction _allocateCallback(func: Function, type: JSTimerType): number {\r\n  const id = GUID++;\r\n  const freeIndex = _getFreeIndex();\r\n  timerIDs[freeIndex] = id;\r\n  callbacks[freeIndex] = func;\r\n  types[freeIndex] = type;\r\n  return id;\r\n}\r\n\r\n/**\r\n * Calls the callback associated with the ID. Also unregister that callback\r\n * if it was a one time timer (setTimeout), and not unregister it if it was\r\n * recurring (setInterval).\r\n */\r\nfunction _callTimer(timerID: number, frameTime: number, didTimeout: ?boolean) {\r\n  if (timerID > GUID) {\r\n    console.warn(\r\n      'Tried to call timer with ID %s but no such timer exists.',\r\n      timerID,\r\n    );\r\n  }\r\n\r\n  // timerIndex of -1 means that no timer with that ID exists. There are\r\n  // two situations when this happens, when a garbage timer ID was given\r\n  // and when a previously existing timer was deleted before this callback\r\n  // fired. In both cases we want to ignore the timer id, but in the former\r\n  // case we warn as well.\r\n  const timerIndex = timerIDs.indexOf(timerID);\r\n  if (timerIndex === -1) {\r\n    return;\r\n  }\r\n\r\n  const type = types[timerIndex];\r\n  const callback = callbacks[timerIndex];\r\n  if (!callback || !type) {\r\n    console.error('No callback found for timerID ' + timerID);\r\n    return;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    Systrace.beginEvent(type + ' [invoke]');\r\n  }\r\n\r\n  // Clear the metadata\r\n  if (type !== 'setInterval') {\r\n    _clearIndex(timerIndex);\r\n  }\r\n\r\n  try {\r\n    if (\r\n      type === 'setTimeout' ||\r\n      type === 'setInterval' ||\r\n      type === 'queueReactNativeMicrotask'\r\n    ) {\r\n      callback();\r\n    } else if (type === 'requestAnimationFrame') {\r\n      callback(global.performance.now());\r\n    } else if (type === 'requestIdleCallback') {\r\n      callback({\r\n        timeRemaining: function () {\r\n          // TODO: Optimisation: allow running for longer than one frame if\r\n          // there are no pending JS calls on the bridge from native. This\r\n          // would require a way to check the bridge queue synchronously.\r\n          return Math.max(\r\n            0,\r\n            FRAME_DURATION - (global.performance.now() - frameTime),\r\n          );\r\n        },\r\n        didTimeout: !!didTimeout,\r\n      });\r\n    } else {\r\n      console.error('Tried to call a callback with invalid type: ' + type);\r\n    }\r\n  } catch (e) {\r\n    // Don't rethrow so that we can run all timers.\r\n    errors.push(e);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    Systrace.endEvent();\r\n  }\r\n}\r\n\r\n/**\r\n * Performs a single pass over the enqueued reactNativeMicrotasks. Returns whether\r\n * more reactNativeMicrotasks are queued up (can be used as a condition a while loop).\r\n */\r\nfunction _callReactNativeMicrotasksPass() {\r\n  if (reactNativeMicrotasks.length === 0) {\r\n    return false;\r\n  }\r\n\r\n  if (__DEV__) {\r\n    Systrace.beginEvent('callReactNativeMicrotasksPass()');\r\n  }\r\n\r\n  // The main reason to extract a single pass is so that we can track\r\n  // in the system trace\r\n  const passReactNativeMicrotasks = reactNativeMicrotasks;\r\n  reactNativeMicrotasks = [];\r\n\r\n  // Use for loop rather than forEach as per @vjeux's advice\r\n  // https://github.com/facebook/react-native/commit/c8fd9f7588ad02d2293cac7224715f4af7b0f352#commitcomment-14570051\r\n  for (let i = 0; i < passReactNativeMicrotasks.length; ++i) {\r\n    _callTimer(passReactNativeMicrotasks[i], 0);\r\n  }\r\n\r\n  if (__DEV__) {\r\n    Systrace.endEvent();\r\n  }\r\n  return reactNativeMicrotasks.length > 0;\r\n}\r\n\r\nfunction _clearIndex(i: number) {\r\n  timerIDs[i] = null;\r\n  callbacks[i] = null;\r\n  types[i] = null;\r\n}\r\n\r\nfunction _freeCallback(timerID: number) {\r\n  // timerIDs contains nulls after timers have been removed;\r\n  // ignore nulls upfront so indexOf doesn't find them\r\n  if (timerID == null) {\r\n    return;\r\n  }\r\n\r\n  const index = timerIDs.indexOf(timerID);\r\n  // See corresponding comment in `callTimers` for reasoning behind this\r\n  if (index !== -1) {\r\n    const type = types[index];\r\n    _clearIndex(index);\r\n    if (\r\n      type !== 'queueReactNativeMicrotask' &&\r\n      type !== 'requestIdleCallback'\r\n    ) {\r\n      deleteTimer(timerID);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * JS implementation of timer functions. Must be completely driven by an\r\n * external clock signal, all that's stored here is timerID, timer type, and\r\n * callback.\r\n */\r\nconst JSTimers = {\r\n  /**\r\n   * @param {function} func Callback to be invoked after `duration` ms.\r\n   * @param {number} duration Number of milliseconds.\r\n   */\r\n  setTimeout: function (\r\n    func: Function,\r\n    duration: number,\r\n    ...args: any\r\n  ): number {\r\n    const id = _allocateCallback(\r\n      () => func.apply(undefined, args),\r\n      'setTimeout',\r\n    );\r\n    createTimer(id, duration || 0, Date.now(), /* recurring */ false);\r\n    return id;\r\n  },\r\n\r\n  /**\r\n   * @param {function} func Callback to be invoked every `duration` ms.\r\n   * @param {number} duration Number of milliseconds.\r\n   */\r\n  setInterval: function (\r\n    func: Function,\r\n    duration: number,\r\n    ...args: any\r\n  ): number {\r\n    const id = _allocateCallback(\r\n      () => func.apply(undefined, args),\r\n      'setInterval',\r\n    );\r\n    createTimer(id, duration || 0, Date.now(), /* recurring */ true);\r\n    return id;\r\n  },\r\n\r\n  /**\r\n   * The React Native microtask mechanism is used to back public APIs e.g.\r\n   * `queueMicrotask`, `clearImmediate`, and `setImmediate` (which is used by\r\n   * the Promise polyfill) when the JSVM microtask mechanism is not used.\r\n   *\r\n   * @param {function} func Callback to be invoked before the end of the\r\n   * current JavaScript execution loop.\r\n   */\r\n  queueReactNativeMicrotask: function (func: Function, ...args: any) {\r\n    const id = _allocateCallback(\r\n      () => func.apply(undefined, args),\r\n      'queueReactNativeMicrotask',\r\n    );\r\n    reactNativeMicrotasks.push(id);\r\n    return id;\r\n  },\r\n\r\n  /**\r\n   * @param {function} func Callback to be invoked every frame.\r\n   */\r\n  requestAnimationFrame: function (func: Function) {\r\n    const id = _allocateCallback(func, 'requestAnimationFrame');\r\n    createTimer(id, 1, Date.now(), /* recurring */ false);\r\n    return id;\r\n  },\r\n\r\n  /**\r\n   * @param {function} func Callback to be invoked every frame and provided\r\n   * with time remaining in frame.\r\n   * @param {?object} options\r\n   */\r\n  requestIdleCallback: function (func: Function, options: ?Object) {\r\n    if (requestIdleCallbacks.length === 0) {\r\n      setSendIdleEvents(true);\r\n    }\r\n\r\n    const timeout = options && options.timeout;\r\n    const id = _allocateCallback(\r\n      timeout != null\r\n        ? (deadline: any) => {\r\n            const timeoutId = requestIdleCallbackTimeouts[id];\r\n            if (timeoutId) {\r\n              JSTimers.clearTimeout(timeoutId);\r\n              delete requestIdleCallbackTimeouts[id];\r\n            }\r\n            return func(deadline);\r\n          }\r\n        : func,\r\n      'requestIdleCallback',\r\n    );\r\n    requestIdleCallbacks.push(id);\r\n\r\n    if (timeout != null) {\r\n      const timeoutId = JSTimers.setTimeout(() => {\r\n        const index = requestIdleCallbacks.indexOf(id);\r\n        if (index > -1) {\r\n          requestIdleCallbacks.splice(index, 1);\r\n          _callTimer(id, global.performance.now(), true);\r\n        }\r\n        delete requestIdleCallbackTimeouts[id];\r\n        if (requestIdleCallbacks.length === 0) {\r\n          setSendIdleEvents(false);\r\n        }\r\n      }, timeout);\r\n      requestIdleCallbackTimeouts[id] = timeoutId;\r\n    }\r\n    return id;\r\n  },\r\n\r\n  cancelIdleCallback: function (timerID: number) {\r\n    _freeCallback(timerID);\r\n    const index = requestIdleCallbacks.indexOf(timerID);\r\n    if (index !== -1) {\r\n      requestIdleCallbacks.splice(index, 1);\r\n    }\r\n\r\n    const timeoutId = requestIdleCallbackTimeouts[timerID];\r\n    if (timeoutId) {\r\n      JSTimers.clearTimeout(timeoutId);\r\n      delete requestIdleCallbackTimeouts[timerID];\r\n    }\r\n\r\n    if (requestIdleCallbacks.length === 0) {\r\n      setSendIdleEvents(false);\r\n    }\r\n  },\r\n\r\n  clearTimeout: function (timerID: number) {\r\n    _freeCallback(timerID);\r\n  },\r\n\r\n  clearInterval: function (timerID: number) {\r\n    _freeCallback(timerID);\r\n  },\r\n\r\n  clearReactNativeMicrotask: function (timerID: number) {\r\n    _freeCallback(timerID);\r\n    const index = reactNativeMicrotasks.indexOf(timerID);\r\n    if (index !== -1) {\r\n      reactNativeMicrotasks.splice(index, 1);\r\n    }\r\n  },\r\n\r\n  cancelAnimationFrame: function (timerID: number) {\r\n    _freeCallback(timerID);\r\n  },\r\n\r\n  /**\r\n   * This is called from the native side. We are passed an array of timerIDs,\r\n   * and\r\n   */\r\n  callTimers: function (timersToCall: Array<number>) {\r\n    invariant(\r\n      timersToCall.length !== 0,\r\n      'Cannot call `callTimers` with an empty list of IDs.',\r\n    );\r\n\r\n    errors.length = 0;\r\n    for (let i = 0; i < timersToCall.length; i++) {\r\n      _callTimer(timersToCall[i], 0);\r\n    }\r\n\r\n    const errorCount = errors.length;\r\n    if (errorCount > 0) {\r\n      if (errorCount > 1) {\r\n        // Throw all the other errors in a setTimeout, which will throw each\r\n        // error one at a time\r\n        for (let ii = 1; ii < errorCount; ii++) {\r\n          JSTimers.setTimeout(\r\n            ((error: Error) => {\r\n              throw error;\r\n            }).bind(null, errors[ii]),\r\n            0,\r\n          );\r\n        }\r\n      }\r\n      throw errors[0];\r\n    }\r\n  },\r\n\r\n  callIdleCallbacks: function (frameTime: number) {\r\n    if (\r\n      FRAME_DURATION - (global.performance.now() - frameTime) <\r\n      IDLE_CALLBACK_FRAME_DEADLINE\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    errors.length = 0;\r\n    if (requestIdleCallbacks.length > 0) {\r\n      const passIdleCallbacks = requestIdleCallbacks;\r\n      requestIdleCallbacks = [];\r\n\r\n      for (let i = 0; i < passIdleCallbacks.length; ++i) {\r\n        _callTimer(passIdleCallbacks[i], frameTime);\r\n      }\r\n    }\r\n\r\n    if (requestIdleCallbacks.length === 0) {\r\n      setSendIdleEvents(false);\r\n    }\r\n\r\n    errors.forEach(error =>\r\n      JSTimers.setTimeout(() => {\r\n        throw error;\r\n      }, 0),\r\n    );\r\n  },\r\n\r\n  /**\r\n   * This is called after we execute any command we receive from native but\r\n   * before we hand control back to native.\r\n   */\r\n  callReactNativeMicrotasks() {\r\n    errors.length = 0;\r\n    while (_callReactNativeMicrotasksPass()) {}\r\n    errors.forEach(error =>\r\n      JSTimers.setTimeout(() => {\r\n        throw error;\r\n      }, 0),\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Called from native (in development) when environment times are out-of-sync.\r\n   */\r\n  emitTimeDriftWarning(warningMessage: string) {\r\n    if (hasEmittedTimeDriftWarning) {\r\n      return;\r\n    }\r\n    hasEmittedTimeDriftWarning = true;\r\n    console.warn(warningMessage);\r\n  },\r\n};\r\n\r\nfunction createTimer(\r\n  callbackID: number,\r\n  duration: number,\r\n  jsSchedulingTime: number,\r\n  repeats: boolean,\r\n): void {\r\n  invariant(NativeTiming, 'NativeTiming is available');\r\n  NativeTiming.createTimer(callbackID, duration, jsSchedulingTime, repeats);\r\n}\r\n\r\nfunction deleteTimer(timerID: number): void {\r\n  invariant(NativeTiming, 'NativeTiming is available');\r\n  NativeTiming.deleteTimer(timerID);\r\n}\r\n\r\nfunction setSendIdleEvents(sendIdleEvents: boolean): void {\r\n  invariant(NativeTiming, 'NativeTiming is available');\r\n  NativeTiming.setSendIdleEvents(sendIdleEvents);\r\n}\r\n\r\nlet ExportedJSTimers: {|\r\n  callIdleCallbacks: (frameTime: number) => any | void,\r\n  callReactNativeMicrotasks: () => void,\r\n  callTimers: (timersToCall: Array<number>) => any | void,\r\n  cancelAnimationFrame: (timerID: number) => void,\r\n  cancelIdleCallback: (timerID: number) => void,\r\n  clearReactNativeMicrotask: (timerID: number) => void,\r\n  clearInterval: (timerID: number) => void,\r\n  clearTimeout: (timerID: number) => void,\r\n  emitTimeDriftWarning: (warningMessage: string) => any | void,\r\n  requestAnimationFrame: (func: any) => any | number,\r\n  requestIdleCallback: (func: any, options: ?any) => any | number,\r\n  queueReactNativeMicrotask: (func: any, ...args: any) => number,\r\n  setInterval: (func: any, duration: number, ...args: any) => number,\r\n  setTimeout: (func: any, duration: number, ...args: any) => number,\r\n|};\r\n\r\nif (!NativeTiming) {\r\n  console.warn(\"Timing native module is not available, can't set timers.\");\r\n  // $FlowFixMe[prop-missing] : we can assume timers are generally available\r\n  ExportedJSTimers = ({\r\n    callReactNativeMicrotasks: JSTimers.callReactNativeMicrotasks,\r\n    queueReactNativeMicrotask: JSTimers.queueReactNativeMicrotask,\r\n  }: typeof JSTimers);\r\n} else {\r\n  ExportedJSTimers = JSTimers;\r\n}\r\n\r\nBatchedBridge.setReactNativeMicrotasksCallback(\r\n  JSTimers.callReactNativeMicrotasks,\r\n);\r\n\r\nmodule.exports = ExportedJSTimers;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}