{"ast":null,"code":"\n\nvar NativeModules = require(\"../BatchedBridge/NativeModules\");\nimport invariant from 'invariant';\nvar turboModuleProxy = global.__turboModuleProxy;\nfunction requireModule(name) {\n  if (global.RN$Bridgeless !== true) {\n    var legacyModule = NativeModules[name];\n    if (legacyModule != null) {\n      return legacyModule;\n    }\n  }\n  if (turboModuleProxy != null) {\n    var module = turboModuleProxy(name);\n    return module;\n  }\n  return null;\n}\nexport function get(name) {\n  return requireModule(name);\n}\nexport function getEnforcing(name) {\n  var module = requireModule(name);\n  invariant(module != null, \"TurboModuleRegistry.getEnforcing(...): '\" + name + \"' could not be found. \" + 'Verify that a module by this name is registered in the native binary.');\n  return module;\n}","map":{"version":3,"names":["NativeModules","require","invariant","turboModuleProxy","global","__turboModuleProxy","requireModule","name","RN$Bridgeless","legacyModule","module","get","getEnforcing"],"sources":["C:/Users/kvnem/ConvergentApp/node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow strict\r\n * @format\r\n */\r\n\r\nconst NativeModules = require('../BatchedBridge/NativeModules');\r\nimport type {TurboModule} from './RCTExport';\r\nimport invariant from 'invariant';\r\n\r\nconst turboModuleProxy = global.__turboModuleProxy;\r\n\r\nfunction requireModule<T: TurboModule>(name: string): ?T {\r\n  // Bridgeless mode requires TurboModules\r\n  if (global.RN$Bridgeless !== true) {\r\n    // Backward compatibility layer during migration.\r\n    const legacyModule = NativeModules[name];\r\n    if (legacyModule != null) {\r\n      return ((legacyModule: $FlowFixMe): T);\r\n    }\r\n  }\r\n\r\n  if (turboModuleProxy != null) {\r\n    const module: ?T = turboModuleProxy(name);\r\n    return module;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function get<T: TurboModule>(name: string): ?T {\r\n  return requireModule<T>(name);\r\n}\r\n\r\nexport function getEnforcing<T: TurboModule>(name: string): T {\r\n  const module = requireModule<T>(name);\r\n  invariant(\r\n    module != null,\r\n    `TurboModuleRegistry.getEnforcing(...): '${name}' could not be found. ` +\r\n      'Verify that a module by this name is registered in the native binary.',\r\n  );\r\n  return module;\r\n}\r\n"],"mappings":";;AAUA,IAAMA,aAAa,GAAGC,OAAO,kCAAkC;AAE/D,OAAOC,SAAS,MAAM,WAAW;AAEjC,IAAMC,gBAAgB,GAAGC,MAAM,CAACC,kBAAkB;AAElD,SAASC,aAAa,CAAiBC,IAAY,EAAM;EAEvD,IAAIH,MAAM,CAACI,aAAa,KAAK,IAAI,EAAE;IAEjC,IAAMC,YAAY,GAAGT,aAAa,CAACO,IAAI,CAAC;IACxC,IAAIE,YAAY,IAAI,IAAI,EAAE;MACxB,OAASA,YAAY;IACvB;EACF;EAEA,IAAIN,gBAAgB,IAAI,IAAI,EAAE;IAC5B,IAAMO,MAAU,GAAGP,gBAAgB,CAACI,IAAI,CAAC;IACzC,OAAOG,MAAM;EACf;EAEA,OAAO,IAAI;AACb;AAEA,OAAO,SAASC,GAAG,CAAiBJ,IAAY,EAAM;EACpD,OAAOD,aAAa,CAAIC,IAAI,CAAC;AAC/B;AAEA,OAAO,SAASK,YAAY,CAAiBL,IAAY,EAAK;EAC5D,IAAMG,MAAM,GAAGJ,aAAa,CAAIC,IAAI,CAAC;EACrCL,SAAS,CACPQ,MAAM,IAAI,IAAI,EACd,6CAA2CH,IAAI,8BAC7C,uEAAuE,CAC1E;EACD,OAAOG,MAAM;AACf"},"metadata":{},"sourceType":"module"}